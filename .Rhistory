summarized_categorical_values_1 <- data.frame(matrix(ncol=8, nrow = 0), check.names = FALSE)
colnames(summarized_categorical_values_1)<-c('year', 'pollutant', 'Tissue', 'Total_N', classification_categories, 'Outliers')
#Empty dataframes for accumulated categirical data
summarized_categorical_values_2_accumulated <- data.frame(matrix(ncol=8, nrow = 0), check.names = FALSE)
colnames(summarized_categorical_values_2_accumulated)<-c('year', 'pollutant', 'Tissue', 'Total_N', classification_categories, 'Outliers')
long_dataset_with_categorical_values_per_year <-as.data.frame(filter(long_dataset_with_categorical_values, Year==year))
long_dataset_with_numerical_values_per_year<-as.data.frame(filter(long_dataset_with_numerical_values_no_zero, Year==year))
# Used to subset categorical and numerical datasets per pollutant
for (i in 1:length(column_names)) {
pollutant_name <- column_names[i]
#Empty dataset for outlier detection using numerical dataset
outlier_detection_using_numerical_values <- data.frame(matrix(ncol=5, nrow = 0), check.names = FALSE)
colnames(outlier_detection_using_numerical_values) <-c('year','Tissue', 'pollutant', 'concentration', 'outlier')
dataset_for_categorical_values_per_pollutant <-as.data.frame(filter(long_dataset_with_categorical_values_per_year, pollutant==pollutant_name))
dataset_for_numerical_values_per_pollutant <-as.data.frame(filter(long_dataset_with_numerical_values_per_year, pollutant== pollutant_name))
# Used to subset categorical and numerical datasets per tissue
for(j in 1:length(tissues)){
tissue_name <- tissues[j]
dataset_for_categorical_values_per_tissue<-as.data.frame(filter(dataset_for_categorical_values_per_pollutant, Tissue==tissue_name))
dataset_for_numerical_values_per_tissue<-as.data.frame(filter(dataset_for_numerical_values_per_pollutant, Tissue==tissue_name)%>%mutate(outlier=NA))
#summarizing dataset based on the count of each classification category with the final column as the sum of the outlier for the detected values using dataset_for_numerical_values_per_tissue
summarized_categorical_values_1[1,1] <- year
summarized_categorical_values_1[1,2] <- pollutant_name
summarized_categorical_values_1[1,3] <- tissue_name
summarized_categorical_values_1[1,4] <- nrow(dataset_for_categorical_values_per_tissue)
summarized_categorical_values_1[1,5] <- sum(str_count(dataset_for_categorical_values_per_tissue$status,category1))
summarized_categorical_values_1[1,6] <- sum(str_count(dataset_for_categorical_values_per_tissue$status,fixed(category2)))
summarized_categorical_values_1[1,7] <- sum(str_count(dataset_for_categorical_values_per_tissue$status,category3))
# This "if function" is mainly used to accommodate datasets after being subsetted for tissue with at least one or no entries. for example; inksac in 2019.
if(nrow(dataset_for_numerical_values_per_tissue)>1){
summarized_categorical_values_1[1,8] <- outliercheck(x=dataset_for_numerical_values_per_tissue, y=input_dataset_numerical_values)[[1]]
outlier_detection_dataset1 <- outliercheck(x=dataset_for_numerical_values_per_tissue, y=input_dataset_numerical_values)[[2]]
outlier_detection_using_numerical_values <- rbind(outlier_detection_using_numerical_values, outlier_detection_dataset1)
partial_input_dataset <- outliercheck(x=dataset_for_numerical_values_per_tissue, y=input_dataset_numerical_values)[[3]]
full_input_dataset <- rbind(full_input_dataset, partial_input_dataset)
}else{ #If the number of rows for dataset_for_numerical_values_per_tissue is less than 1 then we run below code
summarized_categorical_values_1[1,8] <- 0 #put 0 for last column in summarized_categorical_values_1 dataset
#Reconstruct the dataset_for_numerical_values_per_tissue to record the dearth in data for this tissue.
dataset_for_numerical_values_per_tissue[ 1,'Year'] <- paste(year)
dataset_for_numerical_values_per_tissue[ 1,'pollutant'] <- paste(pollutant_name)
dataset_for_numerical_values_per_tissue[ 1,'Tissue'] <- paste(tissue_name)
#If the dataset_for_numerical_values_per_tissue has atleast 1 row then we just keep the concentration
if(nrow(dataset_for_numerical_values_per_tissue)==1){
dataset_for_numerical_values_per_tissue[1,'concentration'] <- paste(dataset_for_numerical_values_per_tissue[,'concentration'])
}else{ #If the dataset_for_numerical_values_per_tissue has no rows then we put the concentration as 0
dataset_for_numerical_values_per_tissue[ 1,'concentration'] <- 0
}
#Whether the dataset_for_numerical_values_per_tissue has 1 or no rows then we record in the last column that there are no outliers sinc there will be no other values to compare that one value of no values with.
dataset_for_numerical_values_per_tissue[ 1,'outlier'] <- 'no'
#Accumulating the dataset_for_numerical_values_per_tissue for a final dataset for all tissues
outlier_detection_using_numerical_values <- rbind(outlier_detection_using_numerical_values, dataset_for_numerical_values_per_tissue)
}
#Accumulating the summarized_categorical_values_1 dataset for a final dataset for all tissues
summarized_categorical_values_2_accumulated <- rbind(summarized_categorical_values_2_accumulated,summarized_categorical_values_1)
} #Tissue
#Accumulating the outlier_detection_using_numerical_values dataset for a final dataset for all tissues
full_dataset_for_outlier_detection_using_numerical_values <- rbind(full_dataset_for_outlier_detection_using_numerical_values, outlier_detection_using_numerical_values)
}# pollutants
summarized_categorical_values_full <- rbind(summarized_categorical_values_full,summarized_categorical_values_2_accumulated)
summarized_categorical_values_yearly_total <- data.frame(matrix(ncol=8, nrow = 0), check.names = FALSE)
colnames(summarized_categorical_values_yearly_total)<-c('year', 'pollutant', 'Tissue', 'Total_N',classification_categories, 'Outliers')
#summarizing datasets based on the count of each classification category using the long_dataset_with_categorical_values_per_year for the yearly categorical values
summarized_categorical_values_yearly_total[1,1] <- year
summarized_categorical_values_yearly_total[1,2] <- 'Total'
summarized_categorical_values_yearly_total[1,3] <- 'Total'
summarized_categorical_values_yearly_total[1,4] <- nrow(long_dataset_with_categorical_values_per_year)
summarized_categorical_values_yearly_total[1,5] <- sum(str_count(long_dataset_with_categorical_values_per_year$status,category1))
summarized_categorical_values_yearly_total[1,6] <- sum(str_count(long_dataset_with_categorical_values_per_year$status,fixed(category2)))
summarized_categorical_values_yearly_total[1,7] <- sum(str_count(long_dataset_with_categorical_values_per_year$status,category3))
summarized_categorical_values_yearly_total[1,8] <- sum(as.numeric(summarized_categorical_values_full$Outliers))
#Accumulating the summarized_categorical_values_yearly_total for each year into one dataset.
summarized_categorical_values_full <- rbind(summarized_categorical_values_full, summarized_categorical_values_yearly_total)
} #years
summarized_categorical_values_full1 <- summarized_categorical_values_full
for(row in 1:nrow(summarized_categorical_values_full1)) {
summarized_categorical_values_full1[row,'Detected'] <- summarized_categorical_values_full1[row,'Detected']-summarized_categorical_values_full1[row,'Outliers']
}
status_levels<- status_levels
final_dataset_categorical_values<- summarized_categorical_values_full1 %>% pivot_longer(all_of(status_levels), names_to = "status", values_to = "values")
final_dataset_for_plotting_by_tissue <- final_dataset_categorical_values %>%group_by(status, Tissue,pollutant, year) %>%mutate(Percentage = (values/Total_N)* 100) #correct (status, Tissue,pollutant, year)
final_dataset_for_plotting_by_pollutants <- final_dataset_categorical_values %>%
filter(!(Tissue == "inksac" & year == 2019)) %>%  # Remove rows with inksacs and 2019
group_by(status,pollutant, year) %>%
mutate(Percentage = (values / Total_N) * 100)
final_dataset_for_plotting_by_tissue[is.na(final_dataset_for_plotting_by_tissue) | final_dataset_for_plotting_by_tissue < 0] = 0
final_dataset_for_plotting_by_pollutants[is.na(final_dataset_for_plotting_by_pollutants) | final_dataset_for_plotting_by_pollutants < 0] = 0
print('Below are the final results from summarizing_and_subsetting_datasets function')
cat("\n")
print('This dataset is called summarized_categorical_values_full')
print(head(summarized_categorical_values_full,10))
cat("\n")
cat("\n")
print('This dataset is called outlier_detection_using_numerical_value')
print(head(outlier_detection_using_numerical_values,10))
cat("\n")
cat("\n")
print('This dataset is called final_dataset_for_plotting_by_tissues')
print(head(as.data.frame(final_dataset_for_plotting_by_tissue),10))
cat("\n")
cat("\n")
print('This dataset is called final_dataset_for_plotting_by_pollutants')
print(head(as.data.frame(final_dataset_for_plotting_by_pollutants),10))
return(list (summarized_categorical_values_full=summarized_categorical_values_full, full_dataset_for_outlier_detection_using_numerical_values=full_dataset_for_outlier_detection_using_numerical_values,input_dataset_numerical_values=input_dataset_numerical_values, final_dataset_for_plotting_by_tissue=final_dataset_for_plotting_by_tissue, final_dataset_for_plotting_by_pollutants=final_dataset_for_plotting_by_pollutants))
}
#This helper function iterates through the outlier_detection_using_numerical_values dataset by row. If the outlier column says yes then it picks out the pollutant for that row to match it with the column name from the input_dataset_numerical_values. When it matches based on the same ID, Year and Tissues and if the user chooses keep the outliers in the dataset, they can do so or replace the outliers with 0 and return a new dataset.
#x=outlier_detection_using_numerical_values
#y=input_dataset_numerical_values
final_dataset_numerical_values <- function(data_list, keep_outliers, column_range){
#LOADING DATASETS FOR PROCESSING
outlier_detection_using_numerical_values <-data_list$full_dataset_for_outlier_detection_using_numerical_values
input_dataset_numerical_values <-data_list$input_dataset_numerical_values
#FOR LOOP USED TO PROCESS FINAL DATASET
for (value in 1:nrow(outlier_detection_using_numerical_values)){
if(outlier_detection_using_numerical_values[value,'outlier']=='yes'){
contaminant <- unique(outlier_detection_using_numerical_values[value,'pollutant'])
for(column_index in 1:length(column_range)){
if(colnames(input_dataset_numerical_values)[column_index+15]!= contaminant){
next
}else{
for (row in 1:nrow(input_dataset_numerical_values)){
if(outlier_detection_using_numerical_values[value,'ID']==input_dataset_numerical_values[row,'ID'] & outlier_detection_using_numerical_values[value,'Year']==input_dataset_numerical_values[row,'Year'] & outlier_detection_using_numerical_values[value,'Tissue']==input_dataset_numerical_values[row,'Tissue']){
if (keep_outliers == FALSE){
input_dataset_numerical_values[row,column_index+15] <- 0
final_dataset_for_numerical_values <- input_dataset_numerical_values
}else{
input_dataset_numerical_values[row,column_index+15]<-input_dataset_numerical_values[row,column_index+15]
final_dataset_for_numerical_values <- input_dataset_numerical_values
}
final_dataset_for_numerical_values <- input_dataset_numerical_values
}else{ #If the IDs, Year and Tissue are not equal to each other then it goes to the value in the input_dataset_numerical_values until the IDs, Year and Tissue match up with those from the outlier_detection_using_numerical_values
next
}
}
}
}
}else{ #If outlier is not equal to 'yes' then it goes to the next value
next
}
}
return(final_dataset_for_numerical_values)
}
#This helper function plots the data distribution for visualization purposes.
visualization <- function(data_list1){
#LOADING DATASET FOR PLOTTING
final_dataset_for_plotting_by_tissue <- data_list1$final_dataset_for_plotting_by_tissue #Loading dataset for plotting distribution by tissues
final_dataset_for_plotting_by_pollutants <- data_list1$final_dataset_for_plotting_by_pollutants #Loading dataset for plotting distribution by pollutants
#Preparing empty lists to store results
list0 <- list()
list0names <- c()
#Used to create plots
if (grepl("Metal", final_dataset_for_plotting_by_pollutants[1,'pollutant'])) {
status_levels<- c('BLOD','BLOQ','Outliers','Detected')
Colors <-setNames( c('#F8766D','#00A9FF','yellow','#00BA38'),status_levels)
pollutant_levels <- c("Metal_A","Metal_B","Metal_C","Metal_D","Metal_E","Metal_F","Metal_G","Metal_H","Metal_I","Metal_J", "Total")
plot_pollutants <-ggplot(final_dataset_for_plotting_by_pollutants, aes(x = factor(pollutant, levels = pollutant_levels), y = Percentage, fill= factor(status, levels = status_levels))) + geom_bar(stat="summary", width=0.97) + scale_fill_manual(values=Colors)+
coord_cartesian(expand = FALSE)+
labs(title = paste('Concentration Detection Summary for Trace Metals',sep =" "),
y = "Classification % per Pollutant", x = "Pollutants", fill= 'Detection Classifications')+
#scale_fill_manual(values=Colors)+
scale_y_continuous(labels = function(x) paste0(x, "%"))+
facet_wrap(vars(year), scales ="free_x", ncol=3, drop = FALSE)+ theme(strip.text = element_text(size = 15, colour = 'black'), axis.text.x = element_text(size = 10, colour = 'black'))
print(plot_pollutants)
list0<-append(list(plot_pollutants),list0, 0)
name0 <- paste("Concentration Detection Summary using pollutants", sep = "")
list0names <- append(list0names,name0)
status_levels<- c('BLOD','BLOQ','Outliers','Detected')
Colors <-setNames( c('#F8766D','#00A9FF','yellow','#00BA38'),status_levels)
tissue_levels <- c("liver","stomach","muscle","inksac","Total")
plot_tissues <-ggplot(final_dataset_for_plotting_by_tissue, aes(x = factor(Tissue, levels = tissue_levels), y = Percentage, fill= factor(status, levels = status_levels))) + geom_bar(stat="summary", width=0.97) + scale_fill_manual(values=Colors)+
coord_cartesian(expand = FALSE)+
labs(title = paste('Concentration Detection Summary for Trace Metals',sep =" "),
y = "Classification % per Tissue", x = "Tissues", fill= 'Detection Classifications')+
#scale_fill_manual(values=Colors)+
scale_y_continuous(labels = function(x) paste0(x, "%"))+
facet_wrap(vars(year), scales ="free_x", ncol=3, drop = FALSE)+ theme(strip.text = element_text(size = 15, colour = 'black'), axis.text.x = element_text(size = 10, colour = 'black'))
print(plot_tissues)
list0<-append(list(plot_tissues),list0, 0)
name0 <- paste("Concentration Detection Summary using tissues", sep = "")
list0names <- append(list0names,name0)
}else{
status_levels<- c('BLOD','BLOQ','Outliers','Detected')
Colors <-setNames( c('#F8766D','#00A9FF','yellow','#00BA38'),status_levels)
pollutant_levels <- c("Adipic_acid","Caprolactam","Chlorpyrifos","Ibuprofen","Total")
plot_pollutants <-ggplot(final_dataset_for_plotting_by_pollutants, aes(x = factor(pollutant, levels = pollutant_levels), y = Percentage, fill= factor(status, levels = status_levels))) + geom_bar(stat="summary", width=0.97) + scale_fill_manual(values=Colors)+
coord_cartesian(expand = FALSE)+
labs(title = paste('Concentration Detection Summary for Organic Compounds',sep =" "),
y = "Classification % per Pollutant", x = "Pollutants", fill= 'Detection Classifications')+
#scale_fill_manual(values=Colors)+
scale_y_continuous(labels = function(x) paste0(x, "%"))+
facet_wrap(vars(year), scales ="free_x", ncol=3, drop = FALSE)+ theme(strip.text = element_text(size = 15, colour = 'black'), axis.text.x = element_text(size = 10, colour = 'black'))
print(plot_pollutants)
list0<-append(list(plot_pollutants),list0, 0)
name0 <- paste("Concentration Detection Summary using pollutants", sep = "")
list0names <- append(list0names,name0)
status_levels<- c('BLOD','BLOQ','Outliers','Detected')
Colors <-setNames( c('#F8766D','#00A9FF','yellow','#00BA38'),status_levels)
tissue_levels <- c("liver","stomach","muscle","inksac","Total")
plot_tissues <-ggplot(final_dataset_for_plotting_by_tissue, aes(x = factor(Tissue, levels = tissue_levels), y = Percentage, fill= factor(status, levels = status_levels))) + geom_bar(stat="summary", width=0.97) + scale_fill_manual(values=Colors)+
coord_cartesian(expand = FALSE)+
labs(title = paste('Concentration Detection Summary for Organic Compounds',sep =" "),
y = "Classification % per Tissue", x = "Tissues", fill= 'Detection Classifications')+
#scale_fill_manual(values=Colors)+
scale_y_continuous(labels = function(x) paste0(x, "%"))+
facet_wrap(vars(year), scales ="free_x", ncol=3, drop = FALSE)+ theme(strip.text = element_text(size = 15, colour = 'black'), axis.text.x = element_text(size = 10, colour = 'black'))
print(plot_tissues)
list0<-append(list(plot_tissues),list0, 0)
name0 <- paste("Concentration Detection Summary using tissues", sep = "")
list0names <- append(list0names,name0)
}
names(list0) <- list0names
return(data_distribution_plots=list0)
}
#This main Function incorporates all the previous functions to help  process the data and create the tables and graphs needed to visualize and interpret the data distribution. The keep_outliers argument is for the final updated dataset. If it is 'FALSE' then it replaces the outliers with 0 in the updated final dataset. If 'TRUE' then it keeps the outliers.
detection_summary <- function(data_list, keep_outliers){
dataset_with_categorical_values <- data_list$dataset_with_categorical_values
dataset_with_numerical_values <- data_list$dataset_with_numerical_values
keep_outliers
x <- data_list$dataset_with_categorical_values
if (grepl("Metal", colnames(x)[16])) {
column_range <- 16:25
classification_categories <- c('BLOD',"BLOQ",'Detected')
status_levels <- c('BLOD',"BLOQ", 'Outliers', 'Detected')
data_list1 <- summarizing_and_subsetting_datasets(dataset_with_numerical_values, dataset_with_categorical_values, classification_categories, status_levels, column_range)
new_dataset <- final_dataset_numerical_values(data_list1, keep_outliers, column_range)
graph <- visualization (data_list1)
}else{
column_range <- 16:19
classification_categories <- c('BLOD',"BLOQ",'Detected')
status_levels <- c('BLOD',"BLOQ", 'Outliers', 'Detected')
#Loading datasets from lists to be subsetted later for data distribution processing
dataset_with_categorical_values <- data_list$dataset_with_categorical_values
dataset_with_numerical_values <- data_list$dataset_with_numerical_values
data_list1 <- summarizing_and_subsetting_datasets(x=dataset_with_numerical_values, y=dataset_with_categorical_values, classification_categories, status_levels, column_range)
new_dataset <- final_dataset_numerical_values(data_list1, keep_outliers, column_range)
graph <- visualization (data_list1)
}
return(list (summarized_and_subsetted_datasets=data_list1, #summarized and subsetted the datasets finding the outliers and counting the classification categories for each pollutant in each year and for each tissue.
updated_dataset_of_numerical_values=new_dataset, #if outliers are chosen to be removed then all the outliers in the updated dataset will be zero
detection_summary_graph=graph))
}
detection_summaries <- detection_summary(datasets_for_organic_compounds, keep_outliers=TRUE)
View(detection_summaries)
View(detection_summaries[["summarized_and_subsetted_datasets"]][["summarized_categorical_values_full"]])
detection_summary_count<-detection_summaries[["summarized_and_subsetted_datasets"]][["summarized_categorical_values_full"]]
reshaped_detection_summary <- detection_summary_count %>%
pivot_wider(
id_cols = c(year, Tissue),
names_from = Pollutant,
values_from = c(Total_N, BLOD, BLOQ, Detected, Outliers),
names_glue = "{Pollutant}_{.value}"
) %>%
arrange(year, Tissue)
reshaped_detection_summary <- detection_summary_count %>%
pivot_wider(
id_cols = c(year, Tissue),
names_from = pollutant,
values_from = c(Total_N, BLOD, BLOQ, Detected, Outliers),
names_glue = "{Pollutant}_{.value}"
) %>%
arrange(year, Tissue)
reshaped_detection_summary <- detection_summary_count %>%
pivot_wider(
id_cols = c(year, Tissue),
names_from = pollutant,
values_from = c(Total_N, BLOD, BLOQ, Detected, Outliers),
names_glue = "{pollutant}_{.value}"
) %>%
arrange(year, Tissue)
print(reshaped_detection_summary)
View(detection_summary_count)
table_list <- detection_summary_count %>%
filter(Total_N > 0) %>%  # optional: skip empty cases
group_split(Year, Pollutant) %>%
lapply(function(sub) {
year <- unique(sub$Year)
pol <- unique(sub$Pollutant)
table <- sub %>%
select(Tissue, Total_N, BLOD, BLOQ, Detected, Outliers)
# Add a title as an attribute (can use later)
# attr(table, "title") <- paste(pol, "-", year)
# return(table)
})
table_list <- detection_summary_count %>%
filter(Total_N > 0) %>%  # optional: skip empty cases
group_split(year, pollutant) %>%
lapply(function(sub) {
year <- unique(sub$year)
pol <- unique(sub$pollutant)
table <- sub %>%
select(Tissue, Total_N, BLOD, BLOQ, Detected, Outliers)
# Add a title as an attribute (can use later)
# attr(table, "title") <- paste(pol, "-", year)
# return(table)
})
View(table_list)
View(table_list[[1]])
table_list <- detection_summary_count %>%
filter(Total_N > 0) %>%  # optional: skip empty cases
group_split(year, pollutant) %>%
lapply(function(sub) {
year <- unique(sub$year)
pol <- unique(sub$pollutant)
table <- sub %>%
select(Tissue, Total_N, BLOD, BLOQ, Detected, Outliers)
#Add a title as an attribute (can use later)
attr(table, "title") <- paste(pol, "-", year)
return(table)
})
table_list <- detection_summary_count %>%
filter(Total_N > 0) %>%  # optional: skip empty cases
group_split(year, pollutant) %>%
lapply(function(sub) {
year <- unique(sub$year)
pol <- unique(sub$pollutant)
table <- sub %>%
select(Tissue, Total_N, BLOD, BLOQ, Detected, Outliers)
#Add a title as an attribute (can use later)
attr(table, "title") <- paste(pol, "-", year)
return(table)
})
View(table_list)
View(table_list[[10]])
table_list <- detection_summary_count %>%
filter(Total_N > 0) %>%  # optional: skip rows with no data
group_split(Year, Pollutant) %>%
lapply(function(sub) {
year <- unique(sub$Year)
pol <- unique(sub$Pollutant)
table <- sub %>%
select(Tissue, Total_N, BLOD, BLOQ, Detected, Outliers)
# Add a title as attribute for labeling later
attr(table, "title") <- paste(pol, "-", year)
return(table)
})
colnames(detection_summary_count) <- gsub("^(\\w)", "\\U\\1", colnames(detection_summary_count), perl = TRUE)
colnames(detection_summary_count) <- gsub("^(\\w)", "\\U\\1", colnames(detection_summary_count), perl = TRUE)
str(detection_summary_count)
table_list <- detection_summary_count %>%
filter(Total_N > 0) %>%  # optional: skip rows with no data
group_split(Year, Pollutant) %>%
lapply(function(sub) {
year <- unique(sub$Year)
pol <- unique(sub$Pollutant)
table <- sub %>%
select(Tissue, Total_N, BLOD, BLOQ, Detected, Outliers)
# Add a title as attribute for labeling later
attr(table, "title") <- paste(pol, "-", year)
return(table)
})
# --- 3. Set layout for grid display ---
n_rows <- 2
n_cols <- 5
n_per_page <- n_rows * n_cols
n_tables <- length(table_list)
n_pages <- ceiling(n_tables / n_per_page)
# --- 4. Output to PDF ---
pdf("Pollutant_Summary_Tables.pdf", width = 14, height = 8)
for (i in seq_len(n_pages)) {
idx_start <- (i - 1) * n_per_page + 1
idx_end <- min(i * n_per_page, n_tables)
tables_to_plot <- table_list[idx_start:idx_end]
plots <- lapply(tables_to_plot, function(tbl) {
title <- attr(tbl, "title")
table_grob <- tableGrob(tbl, rows = NULL)
title_grob <- textGrob(title, gp = gpar(fontsize = 12, fontface = "bold"))
arrangeGrob(title_grob, table_grob, ncol = 1, heights = c(0.15, 1))
})
# Fill in blanks to complete the grid if needed
while (length(plots) < n_per_page) {
plots <- append(plots, list(nullGrob()))
}
do.call(grid.arrange, c(plots, nrow = n_rows, ncol = n_cols))
}
dev.off()
getwd()
# Load required libraries
library(dplyr)
library(tidyr)
library(stringr)
# Capitalize the first letter of all column names if not already
colnames(detection_summary_count) <- gsub("^(\\w)", "\\U\\1", colnames(detection_summary_count), perl = TRUE)
# Get unique combinations of Year and Pollutant
unique_groups <- detection_summary_count %>%
distinct(Year, Pollutant)
# Function to format and print each table
print_pollutant_table <- function(data, year, pollutant) {
subset_df <- data %>%
filter(Year == year, Pollutant == pollutant) %>%
select(Tissue, BLOD, BLOQ, Detected, Outliers)
# Print table name above
cat(paste0("\n", pollutant, " - ", year, "\n"))
# Print formatted table
print(subset_df, row.names = FALSE)
cat("\n")  # Add space between tables
}
# Loop through each Year + Pollutant and print tables
for (i in seq_len(nrow(unique_groups))) {
year <- unique_groups$Year[i]
pollutant <- unique_groups$Pollutant[i]
print_pollutant_table(detection_summary_count, year, pollutant)
}
# Load necessary libraries
library(dplyr)
library(tidyr)
library(purrr)
# Capitalize first letter of column names
colnames(detection_summary_count) <- gsub("^(\\w)", "\\U\\1", colnames(detection_summary_count), perl = TRUE)
# Reorder columns to Tissue, BLOD, BLOQ, Detected, Outliers
reorder_cols <- function(df) {
df %>%
select(Tissue, BLOD, BLOQ, Detected, Outliers)
}
# Get unique years and pollutants
years <- unique(detection_summary_count$Year)
pollutants <- unique(detection_summary_count$Pollutant)
# Function to build tables for one year
build_year_tables <- function(year) {
year_data <- detection_summary_count %>%
filter(Year == year)
# Filter out any "Total" row if it exists
non_total_tables <- year_data %>%
filter(Tissue != "Total") %>%
split(.$Pollutant)
# Create formatted tables
formatted_tables <- imap(non_total_tables, function(df, pol) {
tbl <- reorder_cols(df)
# Add a label row on top
label <- matrix(paste(pol, "-", year), nrow = 1, ncol = ncol(tbl))
colnames(label) <- rep("", ncol(tbl))
tbl <- rbind(as.data.frame(label, stringsAsFactors = FALSE), tbl)
return(tbl)
})
# Combine side-by-side with spacer columns
spacer <- data.frame(" " = rep("", nrow(formatted_tables[[1]])))
joined_tables <- reduce(formatted_tables, function(a, b) {
bind_cols(a, spacer, b)
})
# Print the combined row for the year
cat(paste0("\n====== Year: ", year, " ======\n"))
print(joined_tables, row.names = FALSE)
# Print Total row under, if exists
total_df <- year_data %>% filter(Tissue == "Total")
if (nrow(total_df) > 0) {
cat(paste0("\nTotal - ", year, "\n"))
print(reorder_cols(total_df), row.names = FALSE)
}
cat("\n\n")  # Add space after each year block
}
# Run for each year
walk(years, build_year_tables)
# Load necessary libraries
library(dplyr)
library(tidyr)
library(purrr)
# Capitalize first letter of column names
colnames(detection_summary_count) <- gsub("^(\\w)", "\\U\\1", colnames(detection_summary_count), perl = TRUE)
# Reorder columns to Tissue, BLOD, BLOQ, Detected, Outliers
reorder_cols <- function(df) {
df %>%
select(Tissue,Total_N, BLOD, BLOQ, Detected, Outliers)
}
# Get unique years and pollutants
years <- unique(detection_summary_count$Year)
pollutants <- unique(detection_summary_count$Pollutant)
# Function to build tables for one year
build_year_tables <- function(year) {
year_data <- detection_summary_count %>%
filter(Year == year)
# Filter out any "Total" row if it exists
non_total_tables <- year_data %>%
filter(Tissue != "Total") %>%
split(.$Pollutant)
# Create formatted tables
formatted_tables <- imap(non_total_tables, function(df, pol) {
tbl <- reorder_cols(df)
# Add a label row on top
label <- matrix(paste(pol, "-", year), nrow = 1, ncol = ncol(tbl))
colnames(label) <- rep("", ncol(tbl))
tbl <- rbind(as.data.frame(label, stringsAsFactors = FALSE), tbl)
return(tbl)
})
# Combine side-by-side with spacer columns
spacer <- data.frame(" " = rep("", nrow(formatted_tables[[1]])))
joined_tables <- reduce(formatted_tables, function(a, b) {
bind_cols(a, spacer, b)
})
# Print the combined row for the year
cat(paste0("\n====== Year: ", year, " ======\n"))
print(joined_tables, row.names = FALSE)
# Print Total row under, if exists
total_df <- year_data %>% filter(Tissue == "Total")
if (nrow(total_df) > 0) {
cat(paste0("\nTotal - ", year, "\n"))
print(reorder_cols(total_df), row.names = FALSE)
}
cat("\n\n")  # Add space after each year block
}
# Run for each year
walk(years, build_year_tables)
subset_data <- subset_data %>%
select(Tissue, BLOD, BLOQ, Detected, Outliers)
library(dplyr)
library(tidyr)
library(purrr)
library(gt)
install.packages('gt')
install.packages("gt")
install.packages("gt")
install.packages("gt")
install.packages("gt")
install.packages("gt")
install.packages("gt")

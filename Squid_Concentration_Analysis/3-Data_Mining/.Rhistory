results_gender_within_years[1,1] <- tissues[i]
results_gender_within_years[1,2] <- years[k]
results_gender_within_years[1,3] <- shapiro_wilks_test_status
results_gender_within_years[1,4] <- NA
results_gender_within_years[1,5] <- NA
results_gender_within_years[1,6] <- NA
results_gender_within_years[1,7] <- mean(subsetted_tissue_datatset_by_year_for_females$concentrations)
results_gender_within_years[1,8] <-mean(subsetted_tissue_datatset_by_year_for_males$concentrations)
results_gender_within_years[1,9] <- median(subsetted_tissue_datatset_by_year_for_females$concentrations)
results_gender_within_years[1,10] <-median(subsetted_tissue_datatset_by_year_for_males$concentrations)
accumulated_results_GWY <- rbind(accumulated_results_GWY, results_gender_within_years)
}else{
tt.model <- t.test(concentrations ~ Gender, data = subsetted_tissue_datatset_by_year)
results_gender_within_years[1,1] <- tissues[i]
results_gender_within_years[1,2] <- years[k]
results_gender_within_years[1,3] <- shapiro_wilks_test_status
results_gender_within_years[1,4] <- paste('t=', signif((tt.model$statistic[["t"]]),3), sep = "")
results_gender_within_years[1,5] <- tt.model$parameter[["df"]]
results_gender_within_years[1,6] <- signif((tt.model$p.value),3)
results_gender_within_years[1,7] <- tt.model$estimate[[1]]
results_gender_within_years[1,8] <-tt.model$estimate[[2]]
results_gender_within_years[1,9] <- median(subsetted_tissue_datatset_by_year_for_females$concentrations)
results_gender_within_years[1,10] <-median(subsetted_tissue_datatset_by_year_for_males$concentrations)
accumulated_results_GWY <- rbind(accumulated_results_GWY, results_gender_within_years)
}
}
#Below else if condition checks the normality test results and activates to run tests for non-normally distributed data from the subsetted_tissue_and_gender_dataset_per_year
}else if (nrow(filtered_normality_test_results_by_tissues)!=0 & 'fail' %in% filtered_normality_test_results_by_tissues[,'results']==TRUE){
shapiro_wilks_test_status <- 'fail'
if (years[k]=='2019'){
subsetted_tissue_datatset_by_year_for_2019<-as.data.frame(subsetted_datatset_long_by_tissue %>% group_by(pollutants) %>% subset(Year == years[k]))
subsetted_tissue_datatset_by_year_for_2019_females<-as.data.frame(subsetted_tissue_datatset_by_year_for_2019 %>% group_by(pollutants) %>% subset(Gender == genders[1]))
results_gender_within_years[1,1] <- tissues[i]
results_gender_within_years[1,2] <- years[k]
results_gender_within_years[1,3] <- shapiro_wilks_test_status
results_gender_within_years[1,4] <- NA
results_gender_within_years[1,5] <- NA
results_gender_within_years[1,6] <- NA
results_gender_within_years[1,7] <- mean(subsetted_tissue_datatset_by_year_for_2019_females$concentrations)
results_gender_within_years[1,8] <-NA
results_gender_within_years[1,9] <-median(subsetted_tissue_datatset_by_year_for_2019_females$concentrations)
results_gender_within_years[1,10] <-NA
accumulated_results_GWY <- rbind(accumulated_results_GWY, results_gender_within_years)
}else{
subsetted_tissue_datatset_by_year<-as.data.frame(subsetted_datatset_long_by_tissue %>% group_by(pollutants) %>% subset(Year == years[k]))
subsetted_tissue_datatset_by_year_for_females<-as.data.frame(subsetted_tissue_datatset_by_year %>% group_by(pollutants) %>% subset(Gender == genders[1]))
subsetted_tissue_datatset_by_year_for_males<-as.data.frame(subsetted_tissue_datatset_by_year %>% group_by(pollutants) %>% subset(Gender == genders[2]))
#Below if condition activates if there aren't enough factors/ data to run the hypothesis testing if there are enough factors and data then it runs a wilcox.test(Mann-Whitney U) to check whether males and females differ in their distributions.
if(nrow(subsetted_tissue_datatset_by_year)<2|length(which(subsetted_tissue_datatset_by_year$Gender == genders[1]))<2|length(which(subsetted_tissue_datatset_by_year$Gender == genders[2]))<2|all(subsetted_tissue_datatset_by_year[-1,'concentrations'] == subsetted_tissue_datatset_by_year[1,'concentrations'])){
results_gender_within_years[1,1] <- tissues[i]
results_gender_within_years[1,2] <- years[k]
results_gender_within_years[1,3] <- shapiro_wilks_test_status
results_gender_within_years[1,4] <- NA
results_gender_within_years[1,5] <- NA
results_gender_within_years[1,6] <- NA
results_gender_within_years[1,7] <- mean(subsetted_tissue_datatset_by_year_for_females$concentrations)
results_gender_within_years[1,8] <-mean(subsetted_tissue_datatset_by_year_for_males$concentrations)
results_gender_within_years[1,9] <- median(subsetted_tissue_datatset_by_year_for_females$concentrations)
results_gender_within_years[1,10] <-median(subsetted_tissue_datatset_by_year_for_males$concentrations)
accumulated_results_GWY <- rbind(accumulated_results_GWY, results_gender_within_years)
}else{
mu.model <-wilcox.test(concentrations ~ Gender, data = subsetted_tissue_datatset_by_year, exact = FALSE)
results_gender_within_years[1,1] <- tissues[i]
results_gender_within_years[1,2] <- years[k]
results_gender_within_years[1,3] <- shapiro_wilks_test_status
results_gender_within_years[1,4] <- paste('W=', signif(mu.model$statistic[["W"]],3), sep = "")
results_gender_within_years[1,5] <- NA
results_gender_within_years[1,6] <- signif((mu.model$p.value),3)
results_gender_within_years[1,7] <- mean(subsetted_tissue_datatset_by_year_for_females$concentrations)
results_gender_within_years[1,8] <-mean(subsetted_tissue_datatset_by_year_for_males$concentrations)
results_gender_within_years[1,9] <- median(subsetted_tissue_datatset_by_year_for_females$concentrations)
results_gender_within_years[1,10] <-median(subsetted_tissue_datatset_by_year_for_males$concentrations)
accumulated_results_GWY <- rbind(accumulated_results_GWY, results_gender_within_years)
}
}
#Below else condition does not check the normality test results and only activates when there is no data in subsetted_tissue_and_gender_dataset_per_year dataset. Hence no stats were performed. It records the tissue and year so that it will still be included in the data visualization later on. This is mainly for inksac in 2019.. since this tissue was not tested for that year.
}else{
results_gender_within_years[1,1] <- tissues[i]
results_gender_within_years[1,2] <- years[k]
results_gender_within_years[1,3] <- 'Not enough Observations'
results_gender_within_years[1,4] <- NA
results_gender_within_years[1,5] <- NA
results_gender_within_years[1,6] <- NA
results_gender_within_years[1,7] <- NA
results_gender_within_years[1,8] <-NA
results_gender_within_years[1,9] <- NA
results_gender_within_years[1,10] <-NA
accumulated_results_GWY <- rbind(accumulated_results_GWY, results_gender_within_years)
}
#Below else if condition activates if all values (has to be more than 3 values) for the Gender column within the subsetted_tissue_and_gender_dataset_per_year are the same (indicated with True. This is mainly geared at 2019 since only females were caught in that year). The values in concentration columns, however, are not the same (indicated with false) then it goes on to perform the stats and details for that subsetted dataset.
}else if (all(subsetted_tissue_and_gender_dataset_per_year[-1,'Gender'] == subsetted_tissue_and_gender_dataset_per_year[1,'Gender'])==TRUE & nrow(subsetted_tissue_and_gender_dataset_per_year)>3 & all(subsetted_tissue_and_gender_dataset_per_year[-1,'concentrations'] == subsetted_tissue_and_gender_dataset_per_year[1,'concentrations'])==FALSE){
results_gender_within_years[1,1] <- tissues[i]
results_gender_within_years[1,2] <- years[k]
results_gender_within_years[1,3] <- paste('Only Females')
results_gender_within_years[1,4] <- "Only one group present"
results_gender_within_years[1,5] <- NA
results_gender_within_years[1,6] <- NA
results_gender_within_years[1,7] <- mean(subsetted_tissue_and_gender_dataset_per_year_females$concentrations)
results_gender_within_years[1,8] <-NA
results_gender_within_years[1,9] <- median(subsetted_tissue_and_gender_dataset_per_year_females$concentrations)
results_gender_within_years[1,10] <-NA
accumulated_results_GWY <- rbind(accumulated_results_GWY, results_gender_within_years)
#Below else if condition activates if there are less than 3 values within the subsetted_tissue_and_gender_dataset_per_year. It then goes on to perform the stats and record details for that limited subsetted dataset.
}else{
results_gender_within_years[1,1] <- tissues[i]
results_gender_within_years[1,2] <- years[k]
results_gender_within_years[1,3] <- 'Not enough observations'
results_gender_within_years[1,4] <- NA
results_gender_within_years[1,5] <- NA
results_gender_within_years[1,6] <- NA
results_gender_within_years[1,7] <- mean(subsetted_tissue_and_gender_dataset_per_year_females$concentrations)
results_gender_within_years[1,8] <-mean(subsetted_tissue_and_gender_dataset_per_year_males$concentrations)
results_gender_within_years[1,9] <- median(subsetted_tissue_and_gender_dataset_per_year_females$concentrations)
results_gender_within_years[1,10] <-median(subsetted_tissue_and_gender_dataset_per_year_males$concentrations)
accumulated_results_GWY <- rbind(accumulated_results_GWY, results_gender_within_years)
}
}
}
}
#Below code save results Shapiro-Wilks normality test into list3 for viewing and double checking afterward. It dynamically saves the name of each dataset according to their respective pollutant.
list3<-append(list(normality_test_results_accumulated),list3, 0)
name3 <- paste(pollutant,"_Shapiro_Wilks_test_results", sep = "")
list3names <- append(list3names,name3)
# Step 6: Creating tables for data visualization using accumulated_results_GBY and accumulated_results_GWY datasets----
#Below code creates tables (created as ) from the accumulated_results_GBY data for each pollutant and then saves the table to list1 with their respective name for viewing and double checking afterward.
tt <- ttheme_default(colhead=list(fg_params = list(parse=TRUE)),
base_size = 12,
padding = unit(c(2, 3), "mm"))
cols1 <- c('Gender ','Tissue ','comments ','Test_statistics ','Degrees of Freedom', 'pvalues ','Mean_sq ','Sum of Squares', 'Group_differences ')
colnames(accumulated_results_GBY) <- sapply(cols1, function(x) paste(strwrap(x, width = 12),  collapse="\n"))
tbl1 <- tableGrob(accumulated_results_GBY, rows=NULL, theme=tt)
title <- textGrob("Gender Between Years",gp=gpar(fontsize=15,fontface='bold'))
padding <- unit(1.3,"mm")
table <- gtable_add_rows(tbl1,heights = grobHeight(title) + padding,pos = 0)
table <- gtable_add_grob(table, title, 1, 1, 1,-1, ncol(table))
#Saving tables to list1
list1<-append(list(table),list1, 0)
name1 <- paste(pollutant,"_gender_between_years", sep = "")
list1names <- append(list1names,name1)
#Below code creates tables from the accumulated_results_GWY data for each pollutant and then saves the table to list2 with their respective name for viewing and double checking afterward.
tt1 <- ttheme_default(colhead=list(fg_params = list(parse=TRUE)),
base_size = 11,
padding = unit(c(1, 2), "mm"))
cols2 <- c('Tissue ','Year ','comments ','Test_statistics ', 'Degrees of Freedom ','pvalues ','Mean_Female symbol=(●) ','Mean_Male symbol=(●) ','Median_Female symbol=(——) ', 'Median_Male symbol=(——) ')
colnames(accumulated_results_GWY) <- sapply(cols2, function(x) paste(strwrap(x, width = 12),  collapse="\n"))
tbl2 <- tableGrob(accumulated_results_GWY, rows=NULL, theme=tt1)
title2 <- textGrob("Gender Within Years",gp=gpar(fontsize=15,fontface='bold'))
padding <- unit(1.3,"mm")
table2 <- gtable_add_rows(tbl2,heights = grobHeight(title2) + padding,pos = 0)
table2 <- gtable_add_grob(table2, title2, 1, 1, 1,-1, ncol(table2))
#Saving tables to list1
list2<-append(list(table2),list2, 0)
name2 <- paste(pollutant,"_gender_within_years", sep = "")
list2names <- append(list2names,name2)
#________________________________________________________________________
#Step 7: Below code sets different y-axis ranges for each tissue in a faceted plot. It joins saved y-axis limits with a base template, makes sure the values are numbers and tissues are in a set order, then builds custom y-axis scales for each tissue using scale_y_continuous()----
if(nrow(y_axis_upper_limit_accumulated)!=0){
y_axis_upper_limit_accumulated_copy <- y_axis_upper_limit_accumulated
}else{
Tissue <- tissues[i]
pollutants <- pollutant
y_axis_upper_limit <- 0
y_upper_limit_dataframe <- data.frame(Tissue, pollutants, y_axis_upper_limit)
y_axis_upper_limit_accumulated_copy <- y_upper_limit_dataframe
}
df_scales <- data.frame(
Tissue = c("liver", "stomach", "muscle","inksac"),
ymin = c(0, 0, 0, 0),
ymax = c(NA),
n = c(5, 5, 5,5))
df_scales %<>% inner_join(y_axis_upper_limit_accumulated_copy, by= "Tissue") %>%
mutate(ymax = coalesce(y_axis_upper_limit)) %>%select(Tissue, ymin, ymax, n)
custom_order <- c("liver", "stomach", "muscle", "inksac")
df_scales <- df_scales %>%
mutate(
ymin = as.numeric(ymin),
ymax = as.numeric(ymax),
n = as.numeric(n),
Tissue = factor(Tissue, levels = custom_order)
)
df_scales <- split(df_scales, df_scales$Tissue)
scales <- lapply(df_scales, function(x) {
scale_y_continuous(
limits = c(as.numeric(x$ymin[1]), as.numeric(x$ymax[1])),
n.breaks = as.numeric(x$n[1])
)
})
#Saves full dataset (long format) to list 4.
list4<-append(list(subsetted_datatset_long),list4, 0)
name4 <- paste(pollutant,"_datasets_for_plotting", sep = "")
list4names <- append(list4names,name4)
# Step 8: Below code creates customized boxplots for pollutant concentrations across different tissues, years, and genders. It calculates boxplot stats (min, 25th percentile, median, mean, 75th percentile, max) for each group (Tissue, Year, Gender).Then it plots boxplots using those summary stats (stat = 'identity') and overlays the group means as points.It uses facet_wrap() to show one plot per tissue with individual y-axis scales (free_y), and ggh4x::facetted_pos_scales() to apply custom axis settings from the scales list.----
boxplots <-subsetted_datatset_long %>%
dplyr::group_by(Tissue, Year, Gender) %>%
dplyr::summarize(ymin = quantile(concentrations, 0, na.rm = TRUE),
lower = quantile(concentrations, 0.25, na.rm = TRUE),
median = median(concentrations, na.rm = TRUE),
mean = mean(concentrations, na.rm = TRUE),
upper = quantile(concentrations, 0.75, na.rm = TRUE),
ymax = quantile(concentrations, 1, na.rm = TRUE)) %>%
ggplot(aes(x = Year, fill = Gender)) +
geom_boxplot(stat = 'identity',
aes(ymin = ymin, lower = lower, middle = median, upper = upper,
ymax = ymax)) +
geom_point(aes(y = mean, group = Gender),
position = position_dodge(width = 0.9)) +
labs(title = paste(icons_markdown[h], '<B>',pollutant,'::','</B>',"Boxplots",sep =" "),
y = "Concentrations", x = "Years")+
theme(
plot.title = ggtext::element_markdown(),
strip.text = element_text(size = 12, face = "bold"),
legend.title = element_text(face = "bold", size = 14)
)+
facet_wrap(vars(Tissue), scales ="free_y", ncol=4, drop = FALSE) +
guides(colour="none")+
ggh4x::facetted_pos_scales(y = scales)
#Saves boxplots to list0 for viewing later.
list0<-append(list(boxplots),list0, 0)
name0 <- paste(pollutant,"_plots", sep = "")
list0names <- append(list0names,name0)
h<-h+1
}
#assigning names to multiple lists using pre-defined vectors of names
names(list0)<-list0names
names(list1)<-list1names
names(list2)<-list2names
names(list3)<-list3names
names(list4)<-list4names
return(list (boxplots_for_pollutants=list0, gender_between_years_tables=list1, gender_within_years_tables=list2, Shapiro_Wilks_test_results=list3, datasets_for_plotting=list4))
}
#Calling Main Function. All arguments except remove.zeroes (default is set at False) are required and user has to choose between datasets_for_organic_compounds or datasets_for_heavy_metals for data processing,  also choose a multiplier to help adjust the y_axis since some plots may not show results clearly due to the compression effect or scale distortion of the outliers. For example: The 0.95 means that the upper limit of the y axis will be set at 0.95 * the minimum outlier from the upper quantile for each pollutant resulting in different y axis scales for each pollutant based on their minimum upper outliers. This can be changed as user sees fit. Users also have the option to remove all zeroes and focus on only the detected concentrations or keep them. The results are saved in temporal_gender_comparisons_results list.
gender_temporal_comparisons_results <- temporal_comparisons_between_genders(datasets_for_organic_compounds,remove.zeroes = TRUE)
View(temporal_comparisons_between_genders)
View(gender_temporal_comparisons_results)
#Calling Main Function. All arguments except remove.zeroes (default is set at False) are required and user has to choose between datasets_for_organic_compounds or datasets_for_heavy_metals for data processing,  also choose a multiplier to help adjust the y_axis since some plots may not show results clearly due to the compression effect or scale distortion of the outliers. For example: The 0.95 means that the upper limit of the y axis will be set at 0.95 * the minimum outlier from the upper quantile for each pollutant resulting in different y axis scales for each pollutant based on their minimum upper outliers. This can be changed as user sees fit. Users also have the option to remove all zeroes and focus on only the detected concentrations or keep them. The results are saved in temporal_gender_comparisons_results list.
gender_temporal_comparisons_results <- temporal_comparisons_between_genders(datasets_for_organic_compounds,remove.zeroes = FALSE)
#Calling save_graphs function:
save_graphs(gender_temporal_comparisons_results)
#Below code saves multiple plots (each with accompanying statistical tables) into individual PNG files. It loops through the list of plots and associated tables. For each plot it extracts its name, the plot, and two result tables and saves all three (plot + two tables) in one .png file using grid.arrange().
save_graphs <- function(graph_list) {
# Define the folder where you want to save the PNG files
if (grepl("Fe|Ag", names(graph_list[["boxplots_for_pollutants"]])[[1]])) {
output_folder <- file.path("/Users/mrnobody/Documents/GitHub/Squid-Fest/3-Data_Mining/Data_mining_plots/temporal_gender_comparisons","Heavy_metals")
}else{
output_folder <- file.path("/Users/mrnobody/Documents/GitHub/Squid-Fest/3-Data_Mining/Data_mining_plots/temporal_gender_comparisons","Organic_compounds")
}
# Create the folder if it doesn't exist
if (!dir.exists(output_folder)) {
dir.create(output_folder)
}
# Loop through each plot
for (i in seq_along(graph_list$boxplots_for_pollutants)) {
plot_name <- names(graph_list$boxplots_for_pollutants)[i]
plot_object <- graph_list$boxplots_for_pollutants[[i]]
gender_within_table <- graph_list$gender_within_years_tables[[i]]
gender_between_table <- graph_list$gender_between_years_tables[[i]]
# Debugging info
cat("\n----------\n")
cat("Checking:", plot_name, "\n")
print(class(plot_object))
print(length(plot_object))
# Use tryCatch to handle all errors
tryCatch({
# Create output file path
output_path <- file.path(output_folder, paste0(plot_name, ".png"))
# Save PNG
png(output_path, width = 1400, height = 800)
#Arranges graphs, with tables on one PNG
grid.arrange(
plot_object,
gender_within_table,
gender_between_table,
nrow = 3,
heights = c(2, 1.5, 2)
)
dev.off()
cat("Saved:", output_path, "\n")
}, error = function(e) {
cat("⚠️ Error in", plot_name, ":", e$message, "\n")
})
}
}
#Calling save_graphs function:
save_graphs(gender_temporal_comparisons_results)
OCiconz <- data.frame(pollutants=c("Adipic_acid","Caprolactam","Chlorpyrifos","Ibuprofen"), icons=c("https://img.icons8.com/?size=38&id=ZbNOoXleVpQN&format=png","https://img.icons8.com/?size=38&id=ZbNOoXleVpQN&format=png","https://img.icons8.com/?size=38&id=15168&format=png","https://img.icons8.com/?size=38&id=15168&format=png"))
urls <-OCiconz$icons
names(urls) <- OCiconz$pollutants
#HMicons for Heavy Metals:
HMiconz <- data.frame(pollutants=c("Ag","Cd","Co","Cu","Fe","Hg","Ni","Pb","Tl","Zn"), icons=c("https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=38&id=ZbNOoXleVpQN&format=png","https://img.icons8.com/?size=38&id=ZbNOoXleVpQN&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png"))
urlz <-HMiconz$icons
names(urlz) <- HMiconz$pollutants
#Helper function for creating a clean, minimalistic theme for the plot using theme_minimal(), and then customizes the style (like text sizes, fonts, colors, backgrounds, etc.).
theme_icons <- function(base_size = 10,
title_size = 20,
...){
# CUSTOM THEME:
ggplot2::theme_minimal(base_size = base_size) +
ggplot2::theme(
# axis
axis.text = element_text( size = 10 ),
axis.text.x = element_text( size = 10),
axis.title = element_text( size = 16, face = "bold" ),
# title
plot.title = element_text(size = title_size),
plot.title.position = "plot",
#panel
panel.background = element_rect(fill="white"),
panel.ontop = FALSE,
#legend
legend.text = element_text(size = 15),
legend.title = element_text(face = "bold", size = 16),
#strip
strip.text = element_text(size = 10),
strip.background =element_rect(fill="lightgray"),
strip.text.x = element_markdown(size = 20),
...
)
}
#Helper function to activate the icons for organic compound pollutants in final graph,  It first checks if the icons exist and if they do then they are loaded unto the graph:
markdown_function_for_OC_icons <- function(x) {
# Use file.path() for a safe file path
icon_path <- file.path("OCicons", paste0(x[1], ".png"))
# Construct the HTML string
y <- paste0(" <img src='", icon_path, "' width='17'/>")
return(y)
}
#Helper function to activate the icons for heavy metal pollutants in final graph, It first checks if the icons exist and if they do then they are loaded unto the graph:
markdown_function_for_HM_icons <- function(x) {
# Create file paths correctly
file1 <- file.path("HMicons", paste0(x[1], ".png"))
file2 <- file.path("HMicons", paste0(x[1], "1.png"))
file3 <- file.path("HMicons", paste0(x[1], "2.png"))
# Check which files exist and build the HTML string accordingly
if (file.exists(file1) & file.exists(file2) & file.exists(file3)) {
y <- paste0(" ", "<img src='", file1, "' width='17'/> ",
"<img src='", file2, "' width='17'/> ",
"<img src='", file3, "' width='17'/>")
} else if (file.exists(file1) & file.exists(file2)) {
y <- paste0(" ", "<img src='", file1, "' width='17'/> ",
"<img src='", file2, "' width='17'/>")
} else {
y <- paste0(" ", "<img src='", file1, "' width='17'/>")
}
return(y)
}
#Calling Main Function. All arguments except remove.zeroes (default is set at False) are required and user has to choose between datasets_for_organic_compounds or datasets_for_heavy_metals for data processing,  also choose a multiplier to help adjust the y_axis since some plots may not show results clearly due to the compression effect or scale distortion of the outliers. For example: The 0.95 means that the upper limit of the y axis will be set at 0.95 * the minimum outlier from the upper quantile for each pollutant resulting in different y axis scales for each pollutant based on their minimum upper outliers. This can be changed as user sees fit. Users also have the option to remove all zeroes and focus on only the detected concentrations or keep them. The results are saved in temporal_gender_comparisons_results list.
gender_temporal_comparisons_results <- temporal_comparisons_between_genders(datasets_for_organic_compounds,remove.zeroes = FALSE)
#Calling save_graphs function:
save_graphs(gender_temporal_comparisons_results)
#Below code saves multiple plots (each with accompanying statistical tables) into individual PNG files. It loops through the list of plots and associated tables. For each plot it extracts its name, the plot, and two result tables and saves all three (plot + two tables) in one .png file using grid.arrange().
save_graphs <- function(graph_list) {
# Define the folder where you want to save the PNG files
if (grepl("Fe|Ag", names(graph_list[["boxplots_for_pollutants"]])[[1]])) {
output_folder <- file.path("/Users/mrnobody/Documents/GitHub/Squid-Fest/3-Data_Mining/Data_mining_plots/temporal_gender_comparisons/Heavy_metals")
}else{
output_folder <- file.path("/Users/mrnobody/Documents/GitHub/Squid-Fest/3-Data_Mining/Data_mining_plots/temporal_gender_comparisons/Organic_compounds")
}
# Create the folder if it doesn't exist
if (!dir.exists(output_folder)) {
dir.create(output_folder)
}
# Loop through each plot
for (i in seq_along(graph_list$boxplots_for_pollutants)) {
plot_name <- names(graph_list$boxplots_for_pollutants)[i]
plot_object <- graph_list$boxplots_for_pollutants[[i]]
gender_within_table <- graph_list$gender_within_years_tables[[i]]
gender_between_table <- graph_list$gender_between_years_tables[[i]]
# Debugging info
cat("\n----------\n")
cat("Checking:", plot_name, "\n")
print(class(plot_object))
print(length(plot_object))
# Use tryCatch to handle all errors
tryCatch({
# Create output file path
output_path <- file.path(output_folder, paste0(plot_name, ".png"))
# Save PNG
png(output_path, width = 1400, height = 800)
#Arranges graphs, with tables on one PNG
grid.arrange(
plot_object,
gender_within_table,
gender_between_table,
nrow = 3,
heights = c(2, 1.5, 2)
)
dev.off()
cat("Saved:", output_path, "\n")
}, error = function(e) {
cat("⚠️ Error in", plot_name, ":", e$message, "\n")
})
}
}
#Calling save_graphs function:
save_graphs(gender_temporal_comparisons_results)
#Below code saves multiple plots (each with accompanying statistical tables) into individual PNG files. It loops through the list of plots and associated tables. For each plot it extracts its name, the plot, and two result tables and saves all three (plot + two tables) in one .png file using grid.arrange().
save_graphs <- function(graph_list) {
# Define the folder where you want to save the PNG files
if (grepl("Fe|Ag", names(graph_list[["boxplots_for_pollutants"]])[[1]])) {
output_folder <- file.path("/Users/mrnobody/Documents/GitHub/Squid-Fest/3-Data_Mining/Data_mining_plots/temporal_gender_comparisons/Heavy_metals")
}else{
output_folder <- file.path("/Users/mrnobody/Documents/GitHub/Squid-Fest/3-Data_Mining/Data_mining_plots/temporal_gender_comparisons/Organic_compounds")
}
# Create the folder if it doesn't exist
if (!dir.exists(output_folder)) {
dir.create(output_folder)
}
# Loop through each plot
for (i in seq_along(graph_list$boxplots_for_pollutants)) {
plot_name <- names(graph_list$boxplots_for_pollutants)[i]
plot_object <- graph_list$boxplots_for_pollutants[[i]]
gender_within_table <- graph_list$gender_within_years_tables[[i]]
gender_between_table <- graph_list$gender_between_years_tables[[i]]
# Debugging info
cat("\n----------\n")
cat("Checking:", plot_name, "\n")
print(class(plot_object))
print(length(plot_object))
# Use tryCatch to handle all errors
tryCatch({
# Create output file path
output_path <- file.path(output_folder, paste0(plot_name, ".png"))
# Save PNG
png(output_path, width = 1400, height = 800)
#Arranges graphs, with tables on one PNG
grid.arrange(
plot_object,
gender_within_table,
gender_between_table,
nrow = 3,
heights = c(2, 1.5, 2)
)
dev.off()
cat("Saved:", output_path, "\n")
}, error = function(e) {
cat("⚠️ Error in", plot_name, ":", e$message, "\n")
})
}
}
#Calling save_graphs function:
save_graphs(gender_temporal_comparisons_results)
View(gender_temporal_comparisons_results)
gender_temporal_comparisons_results[["boxplots_for_pollutants"]][["Adipic_acid_plots"]]
gender_temporal_comparisons_results[["boxplots_for_pollutants"]][["Caprolactam_plots"]]
setwd("/Users/mrnobody/Documents/GitHub/Squid-Fest/3-Data_Mining")
#generating the markdown for reading images:
#OCicons for Organic Compounds
OCiconz <- data.frame(pollutants=c("Adipic_acid","Caprolactam","Chlorpyrifos","Ibuprofen"), icons=c("https://img.icons8.com/?size=38&id=ZbNOoXleVpQN&format=png","https://img.icons8.com/?size=38&id=ZbNOoXleVpQN&format=png","https://img.icons8.com/?size=38&id=15168&format=png","https://img.icons8.com/?size=38&id=15168&format=png"))
urls <-OCiconz$icons
names(urls) <- OCiconz$pollutants
#HMicons for Heavy Metals:
HMiconz <- data.frame(pollutants=c("Ag","Cd","Co","Cu","Fe","Hg","Ni","Pb","Tl","Zn"), icons=c("https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png","https://img.icons8.com/?size=38&id=ZbNOoXleVpQN&format=png","https://img.icons8.com/?size=38&id=ZbNOoXleVpQN&format=png","https://img.icons8.com/?size=160&id=8FW995comxyx&format=png"))
urlz <-HMiconz$icons
names(urlz) <- HMiconz$pollutants
#Helper function for creating a clean, minimalistic theme for the plot using theme_minimal(), and then customizes the style (like text sizes, fonts, colors, backgrounds, etc.).
theme_icons <- function(base_size = 10,
title_size = 20,
...){
# CUSTOM THEME:
ggplot2::theme_minimal(base_size = base_size) +
ggplot2::theme(
# axis
axis.text = element_text( size = 10 ),
axis.text.x = element_text( size = 10),
axis.title = element_text( size = 16, face = "bold" ),
# title
plot.title = element_text(size = title_size),
plot.title.position = "plot",
#panel
panel.background = element_rect(fill="white"),
panel.ontop = FALSE,
#legend
legend.text = element_text(size = 15),
legend.title = element_text(face = "bold", size = 16),
#strip
strip.text = element_text(size = 10),
strip.background =element_rect(fill="lightgray"),
strip.text.x = element_markdown(size = 20),
...
)
}
#Helper function to activate the icons for organic compound pollutants in final graph,  It first checks if the icons exist and if they do then they are loaded unto the graph:
markdown_function_for_OC_icons <- function(x) {
# Use file.path() for a safe file path
icon_path <- file.path("OCicons", paste0(x[1], ".png"))
# Construct the HTML string
y <- paste0(" <img src='", icon_path, "' width='17'/>")
return(y)
}
#Helper function to activate the icons for heavy metal pollutants in final graph, It first checks if the icons exist and if they do then they are loaded unto the graph:
markdown_function_for_HM_icons <- function(x) {
# Create file paths correctly
file1 <- file.path("HMicons", paste0(x[1], ".png"))
file2 <- file.path("HMicons", paste0(x[1], "1.png"))
file3 <- file.path("HMicons", paste0(x[1], "2.png"))
# Check which files exist and build the HTML string accordingly
if (file.exists(file1) & file.exists(file2) & file.exists(file3)) {
y <- paste0(" ", "<img src='", file1, "' width='17'/> ",
"<img src='", file2, "' width='17'/> ",
"<img src='", file3, "' width='17'/>")
} else if (file.exists(file1) & file.exists(file2)) {
y <- paste0(" ", "<img src='", file1, "' width='17'/> ",
"<img src='", file2, "' width='17'/>")
} else {
y <- paste0(" ", "<img src='", file1, "' width='17'/>")
}
return(y)
}
#Calling Main Function. All arguments except remove.zeroes (default is set at False) are required and user has to choose between datasets_for_organic_compounds or datasets_for_heavy_metals for data processing,  also choose a multiplier to help adjust the y_axis since some plots may not show results clearly due to the compression effect or scale distortion of the outliers. For example: The 0.95 means that the upper limit of the y axis will be set at 0.95 * the minimum outlier from the upper quantile for each pollutant resulting in different y axis scales for each pollutant based on their minimum upper outliers. This can be changed as user sees fit. Users also have the option to remove all zeroes and focus on only the detected concentrations or keep them. The results are saved in temporal_gender_comparisons_results list.
gender_temporal_comparisons_results <- temporal_comparisons_between_genders(datasets_for_organic_compounds,remove.zeroes = FALSE)
#Calling save_graphs function:
save_graphs(gender_temporal_comparisons_results)
